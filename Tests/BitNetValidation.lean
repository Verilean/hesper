import LSpec
import Hesper
import Hesper.Validation.ReferenceData
import Hesper.Validation.Metrics
import Hesper.Models.BitNet
import Hesper.WebGPU.Device
import Hesper.WebGPU.Buffer
import Hesper.WebGPU.BufferOps
import Hesper.GGUF.Reader

/-!
# BitNet Validation Against Golden Values

Validates the Hesper BitNet implementation against reference outputs from
bitnet.cpp. Golden values are generated by `make golden-values` (see Makefile).

## Available golden values
- `final_norm_output.bin` - Hidden state after final RMSNorm [seq_len, hidden_dim]
- `logits_output.bin` - Logits after LM head [seq_len, vocab_size]
- `input_tokens.bin` - Input token IDs
- `metadata.json` - Model dimensions and prompt info

## Usage
```bash
make golden-values        # Generate reference data from bitnet.cpp
make test-bitnet-validation  # Run this validation
```
-/

namespace Tests.BitNetValidation

open LSpec
open Hesper.Validation.ReferenceData
open Hesper.Validation.Metrics
open Hesper.WebGPU

/-! ## Helpers -/

/-- Load input tokens from binary file -/
def loadInputTokens (dataDir : String) : IO (Array Nat) := do
  let path := dataDir ++ "/input_tokens.bin"
  let bytes ← IO.FS.readBinFile path
  let mut tokens := #[]
  for i in [0:(bytes.size / 4)] do
    let offset := i * 4
    let b0 := bytes.get! offset |>.toUInt32
    let b1 := bytes.get! (offset + 1) |>.toUInt32
    let b2 := bytes.get! (offset + 2) |>.toUInt32
    let b3 := bytes.get! (offset + 3) |>.toUInt32
    let tokenId := (b0 ||| (b1 <<< 8) ||| (b2 <<< 16) ||| (b3 <<< 24)).toNat
    tokens := tokens.push tokenId
  return tokens

/-- Check validation report against tolerance -/
def checkReport (report : ValidationReport) (tolerance : Float := 1e-3) : TestSeq :=
  let sizeCheck := test s!"array size > 0" (report.size > 0)
  let cosineCheck := test s!"cosine similarity > 0.99 (got {report.cosineSimilarity})" (report.cosineSimilarity > 0.99)
  let maxErrCheck := test s!"max abs error < {tolerance} (got {report.maxAbsError})" (report.maxAbsError <= tolerance)
  sizeCheck ++ cosineCheck ++ maxErrCheck

/-- Print detailed report -/
def printReport (name : String) (report : ValidationReport) : IO Unit := do
  IO.println s!"  {name}:"
  IO.println s!"    MSE:              {report.mse}"
  IO.println s!"    RMSE:             {report.rmse}"
  IO.println s!"    Max Abs Error:    {report.maxAbsError}"
  IO.println s!"    Cosine Similarity: {report.cosineSimilarity}"
  IO.println s!"    Size:             {report.size}"

/-! ## Validation Tests -/

/-- Run full forward pass through Hesper and compare with golden values -/
def runValidation (dataDir : String) (modelPath : String) : IO TestSeq := do
  IO.println "==============================================="
  IO.println "  BitNet Validation vs bitnet.cpp Golden Values"
  IO.println "==============================================="
  IO.println ""

  -- Load input tokens
  IO.println "[1/5] Loading input tokens..."
  let inputTokens ← loadInputTokens dataDir
  IO.println s!"  Loaded {inputTokens.size} tokens: {inputTokens}"
  let seqLen := inputTokens.size
  let batchSize := 1

  -- Initialize WebGPU
  IO.println "[2/5] Initializing WebGPU..."
  let inst ← Hesper.init
  let device ← Hesper.WebGPU.getDevice inst
  IO.println "  Device initialized"

  -- Load model
  IO.println "[3/5] Loading BitNet model..."
  let model ← Hesper.Models.BitNet.fromGGUF device modelPath none
  IO.println s!"  Model loaded: dim={model.config.dim}, layers={model.config.numLayers}, vocab={model.config.vocabSize}"

  -- Run forward pass
  IO.println "[4/5] Running Hesper forward pass..."
  let tokensBuf ← Hesper.WebGPU.BufferOps.uploadTokens device inputTokens
  let numLogits := batchSize * seqLen * model.config.vocabSize
  let outputSize := (numLogits * 4).toUSize
  let outputBuf ← Hesper.WebGPU.createBuffer device {
    size := outputSize
    usage := [.storage, .copySrc]
    mappedAtCreation := false
  }

  Hesper.Models.BitNet.forward device model tokensBuf outputBuf batchSize seqLen
  IO.println "  Forward pass complete"

  -- Download Hesper logits
  IO.println "[5/5] Comparing outputs..."
  let hesperLogits ← Hesper.WebGPU.BufferOps.downloadFloatArray device outputBuf numLogits

  -- Print first few logits for last token
  IO.println ""
  IO.println "  Hesper logits (last token, first 5):"
  let lastTokenOffset := (seqLen - 1) * model.config.vocabSize
  for i in [0:min 5 hesperLogits.size] do
    IO.println s!"    [{lastTokenOffset + i}] = {hesperLogits[lastTokenOffset + i]!}"

  -- Load golden logits
  let goldenLogitsPath := dataDir ++ "/logits_output.bin"
  let logitsExists ← System.FilePath.pathExists goldenLogitsPath
  let mut logitsTests : TestSeq := .done

  if logitsExists then
    IO.println ""
    IO.println "  --- Logits Comparison ---"
    let goldenLogitsData ← loadFloatArrayFromFile goldenLogitsPath
    IO.println s!"  Golden logits size: {goldenLogitsData.size}"
    IO.println s!"  Hesper logits size: {hesperLogits.size}"

    -- Print golden logits for last token
    IO.println "  Golden logits (last token, first 5):"
    for i in [0:min 5 goldenLogitsData.size] do
      IO.println s!"    [{lastTokenOffset + i}] = {goldenLogitsData[lastTokenOffset + i]!}"

    if goldenLogitsData.size == hesperLogits.size then
      let goldenRef : LayerOutput := {
        layerIdx := 0, layerName := "logits", shape := [seqLen, model.config.vocabSize], data := goldenLogitsData
      }
      let hesperRef : LayerOutput := {
        layerIdx := 0, layerName := "logits", shape := [seqLen, model.config.vocabSize], data := hesperLogits
      }
      let report := compareLayerOutputs goldenRef hesperRef 1e-3
      printReport "Logits" report

      -- Find top-5 predictions for both
      IO.println ""
      IO.println "  Top-5 predictions (last token):"
      IO.println "  Golden:"
      let goldenLastLogits := goldenLogitsData.extract lastTokenOffset (lastTokenOffset + model.config.vocabSize)
      let hesperLastLogits := hesperLogits.extract lastTokenOffset (lastTokenOffset + model.config.vocabSize)

      -- Simple argmax for top-5 (find max, mask, repeat)
      let mut goldenScores := #[]
      for i in [0:goldenLastLogits.size] do
        goldenScores := goldenScores.push (goldenLastLogits[i]!, i)
      goldenScores := goldenScores.qsort (fun a b => a.1 > b.1)
      for i in [0:min 5 goldenScores.size] do
        let (score, idx) := goldenScores[i]!
        IO.println s!"    #{i+1}: token={idx} score={score}"

      IO.println "  Hesper:"
      let mut hesperScores := #[]
      for i in [0:hesperLastLogits.size] do
        hesperScores := hesperScores.push (hesperLastLogits[i]!, i)
      hesperScores := hesperScores.qsort (fun a b => a.1 > b.1)
      for i in [0:min 5 hesperScores.size] do
        let (score, idx) := hesperScores[i]!
        IO.println s!"    #{i+1}: token={idx} score={score}"

      logitsTests := group "Logits" (checkReport report 1e-3)
    else
      IO.println s!"  WARNING: Size mismatch - golden={goldenLogitsData.size}, hesper={hesperLogits.size}"
      logitsTests := group "Logits" (test "size match" false)
  else
    IO.println "  Logits golden values not found - skipping"

  -- Load golden final_norm output
  let goldenNormPath := dataDir ++ "/final_norm_output.bin"
  let normExists ← System.FilePath.pathExists goldenNormPath
  let mut normTests : TestSeq := .done

  if normExists then
    IO.println ""
    IO.println "  --- Final Norm Output (info only) ---"
    let goldenNormData ← loadFloatArrayFromFile goldenNormPath
    IO.println s!"  Golden final_norm size: {goldenNormData.size} ({seqLen} x {model.config.dim})"
    IO.println s!"  Golden final_norm (first 10):"
    for i in [0:min 10 goldenNormData.size] do
      IO.println s!"    [{i}] = {goldenNormData[i]!}"
    -- Note: We can't easily extract intermediate final_norm from the forward pass
    -- without modifying it. The logits comparison implicitly validates the entire pipeline.
    normTests := group "Final Norm" (test "golden data loaded" true)
  else
    IO.println "  Final norm golden values not found - skipping"

  IO.println ""
  IO.println "==============================================="
  IO.println "  Validation Complete"
  IO.println "==============================================="

  return group "BitNet vs bitnet.cpp" (logitsTests ++ normTests)

end Tests.BitNetValidation

/-! ## Main Entry Point -/

open Tests.BitNetValidation

def main (args : List String) : IO UInt32 := do
  let dataDir := if args.isEmpty then "Tests/golden-values" else args.head!

  -- Check golden values exist
  let metadataPath := dataDir ++ "/metadata.json"
  let metadataExists ← System.FilePath.pathExists metadataPath
  if !metadataExists then
    IO.println s!"Error: Golden values not found: {dataDir}"
    IO.println ""
    IO.println "Generate golden values first:"
    IO.println "  make golden-values"
    return 1

  let modelPath := "../../data/gguf/ggml-model-i2_s.gguf"
  let tests ← runValidation dataDir modelPath

  LSpec.lspecIO (.ofList [("BitNet Validation", [tests])]) ([] : List String)
